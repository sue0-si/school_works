#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
#include "images/space1.h"
#include "images/successScreen.h"
#include "images/playerImage.h"
#include "images/spaceship.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  QUIT,
  END,
  LOSE,
};

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = START;
  struct playerState player;
  struct objectState object1;
  struct objectState enemy1;
  struct objectState enemy2;
  struct objectState enemy3;
  //struct objectState enemy4;
  char arr[50];
  int time;
  int highestScore = 30;

  waitForVBlank();
  startScreen();

  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw

    switch (state) {
      case START:
        
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          fillScreenDMA(BLACK);
          vBlankCounter = 0;
          state = PLAY;
        }
        defaultPlayer(&player);
        defaultObject(&object1);

        enemy1.column = 50;
        enemy1.row = 50;
        enemy1.height = 10;
        enemy1.width = 10;

        defaultObject(&enemy2);
        enemy2.column = 100;
        enemy2.row = 100;

        enemy3.column = 150;
        enemy3.row = 70;
        enemy3.height = 10;
        enemy3.width = 10;
        

        break;

      case PLAY:
        waitForVBlank();
        drawRectDMA(10, 10, 50, 10, BLACK);
        time = vBlankCounter / 60;
        snprintf(arr, 50, "Time: %d", time);
        drawString(10, 10, arr, WHITE);
        

        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = QUIT;
        }
      
        movePlayer(&player, currentButtons);
        

        if (collide(&player, &object1) == 1) {
          if (time < highestScore) {
            highestScore = time;
          }
          state = END;
        }

        if (collide(&player, &enemy1) == 1 || collide(&player, &enemy2) == 1 || time == 30 || collide(&player, &enemy3) == 1) {
          state = LOSE;
        }
        
        waitForVBlank();
        drawRectDMA(20, 20, 240, 140, BLACK);
        drawImageDMA(player.row, player.column, 20, 20, playerImage);
        //drawImageDMA(object.row, object.column, object.width, object.height, spaceship);
        drawRectDMA(enemy1.row, enemy1.column, enemy1.width, enemy1.height, BLUE);
        drawRectDMA(enemy2.row, enemy2.column, enemy2.width, enemy2.height, RED);
        drawRectDMA(enemy3.row, enemy3.column, enemy3.width, enemy3.height, MAGENTA);
        drawImageDMA(object1.row, object1.column, object1.width, object1.height, spaceship);
  
        break;

      case QUIT:
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          startScreen();
          state = START;
        }
        
        break;

      // gameover screen
      case END:
        drawFullScreenImageDMA(astronaut);
        drawString(60, 30, "Successed!", WHITE);
        drawString(70, 50, "Press backspace to restart", WHITE);
        snprintf(arr, 50, "Shortest time: %d", highestScore);
        drawString(10, 10, arr, WHITE);
        //drawString(90, 70, "Shortest time: ");
        state = QUIT;
        break;
      
      case LOSE:
        fillScreenDMA(RED);
        drawString(30, 60, "Failed!!", WHITE);
        drawString(70, 50, "Press backspace to restart", WHITE);
        state = QUIT;
        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  return 0;
}

void startScreen(void) {
  drawFullScreenImageDMA(space1);
  drawString(100, 60, "Press Enter to Start", WHITE);
  drawString(65, 65, "Rescue Astronaut", WHITE);
}

int collide(struct playerState *player, struct objectState *object1) {
  if (player->column < object1->column + object1->height
      && player->row < object1->row + object1->width 
      && player->row + player->width > object1->row
      && player->height + player->column > object1->column
    ) {
      return 1;
  } else {
    return 0;
  }
}

void movePlayer(struct playerState *player, u32 currentButtons) {
  if (KEY_DOWN(BUTTON_LEFT, currentButtons)) {
    player->column -= 2;
    if (player->column < 0) {
        player->column = 0;
    }
  }
  if (KEY_DOWN(BUTTON_RIGHT, currentButtons)) {
    player->column += 2;
    if (player->column > WIDTH - player->width) {
      player->column = WIDTH - player->width;
    }
  }
  if (KEY_DOWN(BUTTON_UP, currentButtons)) {
    player->row -=2;
    if (player->row -20 < 0) {
        player->row = 20;
    }
  } 
  if (KEY_DOWN(BUTTON_DOWN, currentButtons)) {
    player->row += 2;
    if (player->row > HEIGHT - player->height) {
      player->row = HEIGHT - player->height;
    }
  }
}

void defaultPlayer(struct playerState *player) {
  player->row = 30;
  player->column = 10;
  player->width = 20;
  player->height = 20;
}

void defaultObject(struct objectState *object) {
  object->row = 120;
  object->column = 170;
  object->width = 30;
  object->height = 30;
}



